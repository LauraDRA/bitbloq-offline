{"description":"","userTags":[],"hardwareTags":["car","Arduino UNO"],"compiled":false,"imageType":"","videoUrl":"","defaultTheme":"infotab_option_colorTheme","software":{"name":"pythonBloq","content":[[]],"enable":true,"childs":[{"name":"if","content":[[{"alias":"bloqInput","bloqInputId":"ARG1","value":{"name":"phoneReceive","content":[[{"alias":"dynamicDropdown","id":"PHONE","value":"device"}]],"enable":true}},{"alias":"staticDropdown","id":"OPERATOR","value":"=="},{"alias":"bloqInput","bloqInputId":"ARG2","value":{"name":"string","content":[[{"alias":"stringInput","id":"TEXT","value":"avanzar"}]],"enable":true}}]],"enable":true,"childs":[{"name":"botbloqVehicleMove","content":[[{"alias":"staticDropdown","id":"MOVEMENT","value":"FORWARD"},{"alias":"numberInput","id":"DELAY","value":"1000"},{"alias":"numberInput","id":"SPEED","value":"5"}]],"enable":true},{"name":"wait","content":[[{"alias":"numberInput","id":"TIME","value":"2000"}]],"enable":true}]},{"name":"else","content":[[]],"enable":true,"childs":[{"name":"botbloqVehicleStop","content":[[]],"enable":true}]}]},"hardware":{"components":[],"connections":[],"board":"Arduino UNO","robot":"car"},"code":"# coding=utf-8\n\n#!/usr/bin/python\n\nfrom __future__ import absolute_import, print_function, unicode_literals\n\nfrom optparse import OptionParser, make_option\nimport os\nimport sys\nimport socket\nimport uuid\nimport dbus\nimport dbus.service\nimport dbus.mainloop.glib\n\n\n\ntry:\n  from gi.repository import GObject\nexcept ImportError:\n  import gobject as GObject\n\nimport time\n\n###bloques bitbloq para bluetooth###\n\n#escribir un texto en la pantalla del dispositivo movil\ndef escribe_texto(server_sock,texto):\n    server_sock.send(\"%s\\n\" % texto)\n\n#movil emite un sonido\ndef emitir_sonido(server_sock, sonido ):\n    server_sock.send(\"playSound-%s\\n\" % sonido)\n    time.sleep(1)\n\n#recibe datos por voz o texto\ndef recibe_texto(server_sock):\n    data = server_sock.recv(1024)\n    return data\n\n#enciende/apaga linterna del dispositivo\n#enciende la linterna\ndef enciende_linterna(server_sock):\n    server_sock.send(\"turnonFlashlight-\\n\")\n\n#apaga la linterna\ndef apaga_linterna(server_sock):\n    server_sock.send(\"turnoffFlashlight-\\n\")\n\n#leer luz ambiente\ndef leer_luz(server_sock):\n    server_sock.send(\"readLight-\\n\")\n    dato = recibe_texto(server_sock)\n    print(\"nivel luz: %s\" %dato)\n    return dato\n#leer si está cubierto el dispositivo\ndef recibir_estacubierto(server_sock, cv):\n    server_sock.send(\"readProx-%s\n\" % cv)\n    dato = recibe_texto(server_sock)\n    print(\"cubierto: %s\" %dato)\n    return dato\n\n#leer aceleracion\ndef recibir_aceleracion(server_sock, message, axis):\n    server_sock.send(\"%s %s\" % (message, axis))\n    dato = recibe_texto(server_sock)\n    print(\"aceleration: %s\" %dato)\n    return dato\n\n#leer giroscopio\ndef recibir_giroscopio(server_sock, axis):\n    server_sock.send(\"readGyros-%s\n\" % axis)\n    dato = recibe_texto(server_sock)\n    print(\"giroscopio: %s\" %dato)\n    return dato\n\n\n#leer campo magnético\ndef recibir_campomagnetico(server_sock, axis):\n    server_sock.send(\"readMagnetic-%s\n\" % axis)\n    dato = recibe_texto(server_sock)\n    print(\"magnetic field: %s\" %dato)\n    return dato\n\n#leer variables\ndef recibir_orientacion(server_sock, variable):\n    server_sock.send(\"readOrientation-%s\n\" % variable)\n    dato = recibe_texto(server_sock)\n    print(\"variable: %s\" %dato)\n    return dato\n\n\nclass Profile(dbus.service.Object):\n        fd = -1\n\n        @dbus.service.method(\"org.bluez.Profile1\",\n                                        in_signature=\"\", out_signature=\"\")\n        def Release(self):\n                print(\"Release\")\n                mainloop.quit()\n\n        @dbus.service.method(\"org.bluez.Profile1\",\n                                        in_signature=\"\", out_signature=\"\")\n        def Cancel(self):\n                print(\"Cancel\")\n\n        @dbus.service.method(\"org.bluez.Profile1\",\n                                in_signature=\"oha{sv}\", out_signature=\"\")\n        def NewConnection(self, path, fd, properties):\n                self.fd = fd.take()\n                print(\"NewConnection(%s, %d)\" % (path, self.fd))\n\n\n                server_sock = socket.fromfd(self.fd, socket.AF_UNIX, socket.SOCK_STREAM)\n                server_sock.setblocking(1)\n                #server_sock.send(\"This is Edison SPP loopback test\\nAll data will be loopback\\nPlease start:\\n\")\n\n                try:\n                 #hasta aqui se copia y pega todo todo\n                 #aqui se mete el código generado en bitbloq\n\n\n\n\n            \n\n\n#desde aqui se copia y pega todo\n                except IOError:\n                    pass\n\n                server_sock.close()\n                print(\"all done\")\n\n\n\n@dbus.service.method(\"org.bluez.Profile1\",\n                in_signature=\"o\", out_signature=\"\")\ndef RequestDisconnection(self, path):\n    print(\"RequestDisconnection(%s)\" % (path))\n\nif (self.fd > 0):\n        os.close(self.fd)\n        self.fd = -1\n\nif __name__ == '__main__':\n    dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)\n\nbus = dbus.SystemBus()\n\nmanager = dbus.Interface(bus.get_object(\"org.bluez\",\n                \"/org/bluez\"), \"org.bluez.ProfileManager1\")\n\noption_list = [\n        make_option(\"-C\", \"--channel\", action=\"store\",\n                        type=\"int\", dest=\"channel\",\n                        default=None),\n        ]\n\nparser = OptionParser(option_list=option_list)\n\n(options, args) = parser.parse_args()\n\noptions.uuid = \"1101\"\noptions.psm = \"3\"\noptions.role = \"server\"\noptions.name = \"Edison SPP Loopback\"\noptions.service = \"spp char loopback\"\noptions.path = \"/foo/bar/profile\"\noptions.auto_connect = False\noptions.record = \"\"\n\nprofile = Profile(bus, options.path)\n\nmainloop = GObject.MainLoop()\n\nopts = {\n        \"AutoConnect\" :    options.auto_connect,\n}\n\nif (options.name):\n    opts[\"Name\"] = options.name\n\nif (options.role):\n    opts[\"Role\"] = options.role\n\nif (options.psm is not None):\n    opts[\"PSM\"] = dbus.UInt16(options.psm)\n\nif (options.channel is not None):\n    opts[\"Channel\"] = dbus.UInt16(options.channel)\n\nif (options.record):\n    opts[\"ServiceRecord\"] = options.record\n\nif (options.service):\n    opts[\"Service\"] = options.service\n\nif not options.uuid:\n    options.uuid = str(uuid.uuid4())\n\nmanager.RegisterProfile(options.path, options.uuid, opts)\n\nmainloop.run()\n\n\n","useBitbloqConnect":true,"bitbloqConnectBT":{},"exportedFromBitbloqOffline":true,"bitbloqOfflineVersion":"1.0.3","bloqsVersion":"^0.14.5"}